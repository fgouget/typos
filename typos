#!/usr/bin/perl -w
# Copyright (C) 2005-2012 Francois Gouget
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
use strict;
use FileHandle;
use File::Basename;
use Cwd;

my $name0=$0;
$name0 =~ s%^.*/%%;


my $RE_BUNCH=30;

my $verbose;
sub verbose(@)
{
    return print STDERR @_ if ($verbose);
}

my $debug;
sub debug(@)
{
    return print STDERR @_ if ($debug);
}

sub err(@)
{
    print STDERR "$name0:error: ", @_;
}

sub warning(@)
{
    print STDERR "$name0:warning: ", @_;
}

sub hash_count($)
{
    my ($hash)=@_;
    return 0 if (!$hash);
    return scalar(keys %$hash);
}


#####
#
# Building file scanners
#
#####

my $SL_CONTINUE = 0;
my $SL_NEXT_LINE = 1;
my $SL_NEXT_FILE = 2;
sub report_typo($$$$$)
{
    my ($allsets, $filename, $lineno, $line, $group)=@_;
    my $current=$allsets->{current};
    if ($current->{"filenames-only"})
    {
        print "$filename:$lineno\n";
        return $SL_NEXT_FILE;
    }
    if ($current->{"by-error"})
    {
        push @{$allsets->{errors}->{$group}}, "$filename:$lineno: $line";
        return $SL_CONTINUE;
    }
    print "$filename:$lineno: $line";
    return $SL_NEXT_LINE;
}

my %all_words=("" => undef);
sub scan_line($$$$)
{
    my ($allsets, $filename, $lineno, $line)=@_;
    my $current=$allsets->{current};
    my $ignore_re=$current->{_ignore_re};

    foreach my $word (split /\W+/, $line)
    {
        if (exists $all_words{$word})
        {
            next if (!$all_words{$word});
            my $next = report_typo($allsets, $filename, $lineno, $line, $all_words{$word});
            return $next if ($next);
        }
        my $add_word=1;
        if ($current->{"_bad-case"}->{$word})
        {
            if (!defined $ignore_re or $line !~ /$ignore_re/)
            {
                $all_words{$word}=$current->{"_bad-case"}->{$word};
                my $next = report_typo($allsets, $filename, $lineno, $line, $all_words{$word});
                return $next if ($next);
            }
            # In any case, don't mark the word as ok as it is either
            # misspelt or $ignore_re may not apply on another line
            $add_word=undef;
        }
        my $lower=lc($word);
        if ($current->{"_bad-word"}->{$lower})
        {
            if (!defined $ignore_re or $line !~ /$ignore_re/)
            {
                $all_words{$word}=$current->{"_bad-word"}->{$lower};
                my $next = report_typo($allsets, $filename, $lineno, $line, $all_words{$word});
                return $next if ($next);
            }
            # In any case, don't mark the word as ok as it is either
            # misspelt or $ignore_re may not apply on another line
            $add_word=undef;
        }
        if ($current->{extra} and $word =~ /(?:_|[a-z][A-Z])/)
        {
            # Case checks don't make sense for words like CapitalizedWord or
            # UNDERSCORED_WORD. So only do the bad-word checks.
            my $sword=$word;
            $sword =~ s/[0-9_]/ /g;
            $sword =~ s/([a-z])([A-Z])/$1 $2/g;
            foreach my $w (split / /, $sword)
            {
                $lower=lc($w);
                if ($current->{"_bad-word"}->{$lower})
                {
                    if (!defined $ignore_re or $line !~ /$ignore_re/)
                    {
                        $all_words{$word}=$current->{"_bad-word"}->{$lower};
                        my $next = report_typo($allsets, $filename, $lineno, $line, $all_words{$word});
                        return $next if ($next);
                    }
                    # In any case, don't mark the word as ok as it is either
                    # misspelt or $ignore_re may not apply on another line
                    $add_word=undef;
                }
            }
        }
        $all_words{$word}=undef if ($add_word);
    }
}

sub scan_check($$$$$$)
{
    my ($allsets, $category, $filename, $lineno, $line, $regexps)=@_;
    my $current=$allsets->{current};
    my $ignore_re=$current->{_ignore_re};

    foreach my $item (@$regexps)
    {
        my $regexp=sprintf($current->{"${category}_format"}, $item);
        next if ($line !~ /$regexp/);
        next if (defined $ignore_re and $line =~ /$ignore_re/);
        my $next = report_typo($allsets, $filename, $lineno, $line, $current->{$category}->{$item});
        return $next if ($next);
    }
    return 0;
}

sub scan_check_extra($$$$$$)
{
    my ($allsets, $category, $filename, $lineno, $line, $regexps)=@_;
    my $current=$allsets->{current};
    my $ignore_re=$current->{_ignore_re};

    foreach my $item (@$regexps)
    {
        my $regexp=sprintf($current->{"${category}_format"}, $item);
        my $match;
        if ($line =~ /(?:\b|[0-9_])(?:$regexp)(?:\b|[0-9_])/)
        {
            $match=1;
        }
        elsif ($line =~ /[a-z](?:$regexp)(?:\b|[0-9_])/)
        {
            my $matched=$&;
            $match=1 if ($matched =~ /^[a-z][A-Z][a-z]*$/);
        }
        elsif ($line =~ /[a-z](?:$regexp)[A-Z]/)
        {
            my $matched=$&;
            $match=1 if ($matched =~ /^[a-z][A-Z][a-z]*[A-Z]$/);
        }
        elsif ($line =~ /(?:\b|[0-9_])(?:$regexp)[A-Z]/)
        {
            my $matched=$&;
            $match=1 if ($matched =~ /^[A-Z][a-z]*[A-Z]$/);
        }
        next if (!$match);
        next if (defined $ignore_re and $line =~ /$ignore_re/);
        my $next = report_typo($allsets, $filename, $lineno, $line, $current->{$category}->{$item});
        return $next if ($next);
    }
    return 0;
}

sub build_scan_check($$$)
{
    my ($allsets, $current, $category)=@_;

    my @code;
    my @list=sort keys %{$current->{$category}};
    my $checker;
    if ($category eq "_bad-word_re" and $current->{extra})
    {
        $checker="scan_check_extra";
    }
    else
    {
        $checker="scan_check";
    }
    my $i=0;
    while ($i < @list)
    {
        my @buf;
        for (my $j=$i; $j < $i+$RE_BUNCH and $j < @list; $j++)
        {
            my $re=$list[$j];
            $re =~ s%/%\\/%g;
            push @buf, $re;
        }
        $i+=$RE_BUNCH;
        my $regexp="(?:" . join("|", @buf) . ")";
        $regexp=sprintf($current->{"${category}_format"}, $regexp);
        push @code, ("if (\$line =~ /$regexp/)",
                     "{",
                     "    my \$regexps=[",
                     (map { "        " . quote_string($_) . "," } @buf),
                     "    ];",
                     "    if ($checker(\$allsets, " . quote_string($category) . ", \$filename, \$lineno, \$line, \$regexps))",
                     "    {",
                     "        next;",
                     "    }",
                     "}");
    }
    return @code;
}

my @build_scanner_options=(
    "bad-case_re", "bad-word_re", "bad-expression_re",
    "builtin", "codespell", "extra", "lintian"
    );
sub build_scanner($$)
{
    my ($allsets, $current)=@_;

    $current->{"_bad-word_re_format"}=$current->{extra} ? "(?i)\%s" : "(?i)(?:\\b|[0-9_])\%s(?:\\b|[0-9_])";
    $current->{"_bad-expression_re_format"}="\%s";
    $current->{"_bad-case_re_format"}="\\b\%s\\b";
    my @code=("sub ",
              "{",
              "    my (\$fh, \$filename)=\@_;",
              "",
              "    my \$lineno=0;",
              "    while (my \$line=<\$fh>)",
              "    {",
              "        \$lineno++;",
              "        my \$next = scan_line(\$allsets, \$filename, \$lineno, \$line);",
              "        next if (\$next == \$SL_NEXT_LINE);",
              "        last if (\$next == \$SL_NEXT_FILE);",
              build_scan_check($allsets, $current, "_bad-word_re"),
              build_scan_check($allsets, $current, "_bad-expression_re"),
              build_scan_check($allsets, $current, "_bad-case_re"),
              "    }",
              "}",
              "");
    if ($debug)
    {
        my $fh=FileHandle->new(">#code.txt#");
        if ($fh)
        {
            print $fh join("\n", @code);
            close ($fh);
        }
    }
    $current->{scanner}=eval join("\n", @code);
    if ($@)
    {
        err("scanner compilation error: $@\n");
        exit 1;
    }
}

sub copy_scanner($$)
{
    my ($src, $dst)=@_;
    foreach my $field ("_bad-case_re_format", "_bad-expression_re_format",
                       "_bad-word_re_format", "scanner")
    {
        $dst->{$field}=$src->{$field};
    }
}


#####
#
# Command-line and rc file processing
#
#####

sub get_true_by_default($)
{
    my ($value)=@_;
    return (defined $value ? $value : 1);
}

sub rchandle2argv($$)
{
    my ($fh, $filename)=@_;
    verbose("reading '$filename'\n");

    my $argv=[];
    my $lines=[];
    my $repeat;
    my $lineno=0;
    while (my $line=<$fh>)
    {
        $lineno++;
        next if ($line =~ /^\s*#/);
        chomp $line;
        if (defined $repeat)
        {
            if ($line =~ s/^\s+// and $line ne "")
            {
                push @$argv, $repeat, $line;
                push @$lines, $lineno, $lineno;
                next;
            }
            $repeat=undef;
        }
        if ($line =~ s/^([-a-z0-9_]+)\s*=\s*//)
        {
            if ($line eq "")
            {
                $repeat="--$1";
            }
            else
            {
                push @$argv, "--$1", $line;
                push @$lines, $lineno, $lineno;
            }
        }
        elsif ($line =~ /^[a-z0-9_]+$/)
        {
            push @$argv, "--$line";
            push @$lines, $lineno;
        }
        elsif ($line !~ /^\s*$/)
        {
            err("$filename:$lineno: invalid line format: $line\n");
            return undef;
        }
    }
    close($fh);
    debug("typosrc(", dirname($filename), "): '", join("' '", @$argv), "'\n");
    return ($argv, $lines);
}

sub cvsignore2argv($$)
{
    my ($allsets, $filename)=@_;

    my $fh=FileHandle->new($filename);
    if (!$fh)
    {
        err("unable to open '$filename' for reading: $!\n");
        exit 1;
    }
    verbose("reading '$filename'\n");

    my $argv=[];
    my $lines=[];
    my $lineno=0;
    while (my $line=<$fh>)
    {
        $lineno++;
        chomp $line;
        foreach my $glob (split / +/, $line)
        {
            $glob =~ s!([{}().+^|\$])!\\$1!g;
            if ($glob !~ s!\*$!!)
            {
                # Globs must implicitly match up to the end of the string
                $glob .= "\$";
            }
            $glob =~ s!\?!.!g;
            $glob =~ s!\*![^/]*!g;
            # The CVS globs only match files in the current directory
            push @$argv, "--exclude", "^./$glob";
            push @$lines, $lineno, $lineno;
        }
    }
    close($fh);
    debug("cvsignore: '", join("' '", @$argv), "'\n");
    return ($argv, $lines);
}

sub gitignore2argv($$)
{
    my ($allsets, $filename)=@_;

    my $fh=FileHandle->new($filename);
    if (!$fh)
    {
        err("unable to open '$filename' for reading: $!\n");
        exit 1;
    }
    verbose("reading '$filename'\n");

    my $argv=[];
    my $lines=[];
    my $lineno=0;
    while (my $glob=<$fh>)
    {
        $lineno++;
        chomp $glob;
        $glob =~ s/^\s*//;
        $glob =~ s/\s*$//;
        next if ($glob eq "" or $glob =~ /^#/);

        my $option=($glob =~ s/^!\s*// ? "--include" : "--exclude");
        $glob =~ s!([{}().+^|\$])!\\$1!g;
        if ($glob =~ s!^\*!!)
        {
            # No need for the '*' prefix with regular expressions
            ;
        }
        elsif ($glob =~ s!^/!^./!)
        {
            # This only matches files in the current directory
            # We will replace the '^./' prefix with the absolute path
            # a bit later
            ;
        }
        else
        {
            # Globs must implicitly match from the start of the string,
            # in this case from the start of the basename
            $glob = "/$glob";
        }
        if ($glob !~ s!\*$!!)
        {
            # Globs must implicitly match up to the end of the string
            $glob .= "\$";
        }
        $glob =~ s!\?!.!g;
        $glob =~ s!\*![^/]*!g;
        push @$argv, $option, $glob;
        push @$lines, $lineno, $lineno;
    }
    close($fh);
    debug("gitignore: '", join("' '", @$argv), "'\n");
    return ($argv, $lines);
}

# For lintian a word is any contiguous set of characters with no space,
# whereas in typos we require a word boundary on both sides. Usually it
# does not matter but there are a few exceptions like 'GTK' which is not
# supposed to match 'GTK+'. So we simply blacklist these.
# We also blacklist some Lintian and Codespell entries because they simply
# cause too many false positives.
my %blacklist=(
    "acount" => 1,    # Too many false positives
    "adn" => 1,       # Too many false positives
    "ang" => 1,       # Too many false positives
    "beng" => 1,      # Too many false positives
    "cas" => 1,       # Too many false positives
    "cant" => 1,      # Too many false positives
    "cancelation" => 1, # US spelling
    "dependant" => 1, # Valid word, just different meaning from dependent
    "didnt" => 1,     # Too many false positives
    "doesnt" => 1,    # Too many false positives
    "dont" => 1,      # Too many false positives
    "GTK" => 1,       # Correct form is GTK+ which is not a word
    "isn" => 1,       # Too many false positives
    "isnt" => 1,      # Too many false positives
    "modeled" => 1,   # US spelling
    "nam" => 1,       # Too many false positives (specifically Viet Nam)
    "nto" => 1,       # Too many false positives
    "ok" => 1,        # Too many false positives
    "ot" => 1,        # Too many false positives
    "pich" => 1,      # Too many false positives
    "pres" => 1,      # Too many false positives
    "ressize" => 1,   # Too many false positives
    "seeked" => 1,    # Too many false positives
    "teh" => 1,       # Too many false positives
    "TEX" => 1,       # Too many false positives
    "ths" => 1,       # Too many false positives
    "tje" => 1,       # Too many false positives
    "usera" => 1,     # Too many false positives
    "wasn" => 1,      # Too many false positives
    "whic" => 1,      # Too many false positives
    "wih" => 1,       # Too many false positives
    );

sub lintian2argv($$)
{
    my ($filename, $opt)=@_;
    my $fh=FileHandle->new($filename);
    if (!$fh)
    {
        err("unable to open '$filename' for reading: $!\n");
        exit 1;
    }
    verbose("reading '$filename'\n");

    my $argv=[];
    my $lines=[];
    my $lineno=0;
    while (my $line=<$fh>)
    {
        $lineno++;
        next if ($line =~ /^\s*(?:#|$)/);
        chomp $line;
        my (@fields)=split /[|]/, $line;
        if (@fields != 3)
        {
            err("$filename:$lineno: unknown line format: $line\n");
            return undef;
        }
        my $re=$fields[0];
        if (exists $blacklist{$re})
        {
            # See the blacklist definition above.
            next;
        }
        elsif ($opt eq "bad-expression")
        {
            $re="\\b(?:$re)\\b";
        }
        elsif ($opt eq "bad-case" and $re !~ /[A-Z]/)
        {
            # The all-lowercase words cause too many false positives in
            # non-English files such as in code. So ignore them.
            next;
        }
        push @$argv, "--$opt", "$re -> $fields[2]";
        push @$lines, $lineno;
    }
    close($fh);
    debug("lintian(", basename($filename), "): '", join("' '", @$argv), "'\n");
    return ($argv, $lines);
}

sub codespell2argv($)
{
    my ($filename)=@_;
    my $fh=FileHandle->new($filename);
    if (!$fh)
    {
        err("unable to open '$filename' for reading: $!\n");
        exit 1;
    }
    verbose("reading '$filename'\n");

    my $argv=[];
    my $lines=[];
    my $lineno=0;
    while (my $line=<$fh>)
    {
        $lineno++;
        next if ($line =~ /^\s*(?:#|$)/);
        chomp $line;
        my (@fields)=split /->/, $line;
        if (@fields != 2)
        {
            err("$filename:$lineno: unknown line format: $line\n");
            return undef;
        }
        next if (exists $blacklist{$fields[0]});
        next if ($fields[1] =~ /, disable/);
        push @$argv, "--bad-word", "$fields[0] -> $fields[1]";
        push @$lines, $lineno;
    }
    close($fh);
    debug("codespell: '", join("' '", @$argv), "'\n");
    return ($argv, $lines);
}

sub wikipedia2argv($)
{
    my ($filename)=@_;
    my $fh=FileHandle->new($filename);
    if (!$fh)
    {
        err("unable to open '$filename' for reading: $!\n");
        exit 1;
    }
    verbose("reading '$filename'\n");

    my $argv=[];
    my $lines=[];
    my $lineno=0;
    while (my $line=<$fh>)
    {
        $lineno++;
        chomp $line;
        if ($line =~ /^^(\w+)-&gt;(\w+)$/)
        {
            my ($bad, $good)=($1, $2);
            next if (exists $blacklist{$bad});
            push @$argv, "--bad-word", "$bad -> $good";
            push @$lines, $lineno;
        }
    }
    close($fh);
    debug("wikipedia: '", join("' '", @$argv), "'\n");
    return ($argv, $lines);
}

sub expand_regexp($);
sub expand_regexp($)
{
    my ($re)=@_;
    return undef if ($re =~ /[.*+{\\]/);

    # Handle simple word alternatives: a|b
    if ($re =~ /^\w+(?:\|\w+)*$/)
    {
        my @words=split /\|/, $re;
        return \@words;
    }

    # Handle brackets: [ab]?
    if ($re =~ /^(.*)\[([^-^|()\[\]?]+)\](\?)?(.*)$/)
    {
        my ($before, $chars, $optional, $after)=($1, $2, $3, $4);
        my @words=();
        if ($optional)
        {
            my $list=expand_regexp("$before$after");
            return undef if (!$list);
            push @words, @$list;
        }
        foreach my $char (split //, $chars)
        {
            my $list=expand_regexp("$before$char$after");
            return undef if (!$list);
            push @words, @$list;
        }
        return \@words;
    }
    return undef if ($re =~ /[[\\]]/);

    # Handle optional characters: a?
    if ($re =~ /^(.*)(\w)\?(.*)$/)
    {
        my ($before, $char, $after)=($1, $2, $3);
        my $list=expand_regexp("$before$after");
        return undef if (!$list);
        my @words=@$list;
        $list=expand_regexp("$before$char$after");
        return undef if (!$list);
        push @words, @$list;
        return \@words;
    }

    # Handle paranthese: (a|b)?
    if ($re =~ /^(.*)\((\w+(?:\|\w+)*)\)(\?)?(.*)$/)
    {
        my ($before, $inside, $optional, $after)=($1, $2, $3, $4);
        my @words=();
        if ($optional)
        {
            my $list=expand_regexp("$before$after");
            return undef if (!$list);
            push @words, @$list;
        }
        foreach my $word (split /\|/, $inside)
        {
            my $list=expand_regexp("$before$word$after");
            return undef if (!$list);
            push @words, @$list;
        }
        return \@words;
    }
    return undef if ($re =~ /[()]/);

    # The regexp is too complex, give up
    return undef;
}

sub get_options_set($$$;$)
{
    my ($argv, $lines, $filename, $extra_options)=@_;
    @ARGV=@$argv if (defined $argv);

    use Getopt::Long;
    Getopt::Long::Configure("pass_through");
    my ($opt_set, @extra);
    if ($extra_options)
    {
        $opt_set=$extra_options;
        @extra=keys %$extra_options;
    }
    else
    {
        $opt_set={};
        @extra=();
    }
    GetOptions($opt_set, @extra,
               "builtin!",
               "rc!",
               "cvsignore!",
               "gitignore!",

               "extra!",
               "bad-word=s@",
               "bad-expression=s@",
               "bad-case=s@",
               "ignore=s@",
               "by-error!",
               "filenames-only!",

               "lintian!",

               "get-codespell",
               "codespell!",

               "get-wikipedia",
               "wikipedia!",

               "all!",
               "include=s@",
               "exclude=s@");
    if (@ARGV)
    {
        my $i=0;
        foreach my $item (@ARGV)
        {
            if (defined $argv)
            {
                while ($item ne $argv->[$i])
                {
                    $i++;
                }
                err("$filename:$lines->[$i]: unknown option '$item'\n");
            }
            else
            {
                err("unknown option '$item'\n");
            }
        }
        return undef;
    }

    if ($filename eq "cmdline")
    {
        $opt_set->{builtin}=1 if (!defined $opt_set->{builtin});
        $opt_set->{lintian}=1 if (!defined $opt_set->{lintian});
        if (defined $ENV{HOME})
        {
            if (!defined $opt_set->{codespell} and
                -r "$ENV{HOME}/.$name0.codespell")
            {
                $opt_set->{codespell}=1 ;
            }
            if (!defined $opt_set->{wikipedia} and
                -r "$ENV{HOME}/.$name0.wikipedia")
            {
                $opt_set->{wikipedia}=1 ;
            }
        }
        $opt_set->{rc}=1 if (!defined $opt_set->{rc});
    }
    $opt_set->{_filename}=$filename;

    # Convert the paths relative to this directory
    my $cur_dir=($filename =~ m!/! ? dirname($filename) : cwd());
    $cur_dir =~ s!([{}()?.*+^|\$])!\\$1!g;
    foreach my $key ("include", "exclude")
    {
        if (defined $opt_set->{$key})
        {
            map { s!^\^\./!^$cur_dir/! } @{$opt_set->{$key}};
        }
    }
    # FIXME: Check each regular expression and try to match them to line numbers if they don't compile
    foreach my $category ("bad-case", "bad-expression", "bad-word")
    {
        my $list=$opt_set->{$category};
        next if (!$list);
        $opt_set->{$category}={};
        $opt_set->{"${category}_re"}={};
        foreach my $entry (@$list)
        {
            if ($entry !~ s/\s+->\s+(.*)$//)
            {
                err("found an invalid $category entry in $opt_set->{_filename}: $entry\n");
                next;
            }
            my $group=$1;
            my $words;
            $words=expand_regexp($entry) if ($category ne "bad-expression");
            if (!$words)
            {
                $opt_set->{"${category}_re"}->{$entry}=$group;
            }
            else
            {
                foreach my $word (@$words)
                {
                    $word=lc($word) if ($category eq "bad-word");
                    $opt_set->{$category}->{$word}=$group;
                }
            }
        }
    }
    verbose("out ", hash_count($opt_set->{"bad-word"}), " / ",
            hash_count($opt_set->{"bad-word_re"}), " words, ",
            hash_count($opt_set->{"bad-case"}), " / ",
            hash_count($opt_set->{"bad-case_re"}), " case, ",
            hash_count($opt_set->{"bad-expression_re"}), " expressions\n");

    return $opt_set;
}

sub read_rc_files($$)
{
    my ($allsets, $dir)=@_;
    my ($opt_set, $read_files);

    my $filename="$dir/.typosrc";
    if (-f $filename)
    {
        my $fh=FileHandle->new($filename);
        if (!$fh)
        {
            err("unable to open '$filename' for reading: $!\n");
            exit 1;
        }
        my ($argv, $lines)=rchandle2argv($fh, $filename);
        close($fh);
        $opt_set=get_options_set($argv, $lines, $filename);
        push @{$allsets->{rcstack}}, $opt_set;
        $read_files=1;
    }

    # FIXME: Also take into account $CVSROOT/CVSROOT/cvsignore?
    # FIXME: Also take into account $HOME/.cvsignore
    # FIXME: Also take into account $CVSIGNORE
    $filename="$dir/.cvsignore";
    if (get_true_by_default($allsets->{cmdline}->{cvsignore}) and
        get_true_by_default($opt_set->{cvsignore}) and
        -f $filename)
    {
        my ($argv, $lines)=cvsignore2argv($opt_set, $filename);
        push @{$allsets->{rcstack}}, get_options_set($argv, $lines, $filename);
        $read_files=1;
    }

    $filename="$dir/.gitignore";
    if (get_true_by_default($allsets->{cmdline}->{gitignore}) and
        get_true_by_default($opt_set->{gitignore}) and
        -f $filename)
    {
        my ($argv, $lines)=gitignore2argv($opt_set, $filename);
        push @{$allsets->{rcstack}}, get_options_set($argv, $lines, $filename);
        $read_files=1;
    }
    return $read_files;
}

sub merge_regexp_hash($$$$)
{
    my ($merged, $option, $src, $ignore_duplicates)=@_;

    foreach my $key (keys %$src)
    {
        my $group=$src->{$key};
        my $regexp=$key;
        $regexp =~ s/\((?!\?)/(?:/g;
        next if ($regexp eq "");
        if (!exists $merged->{$option}->{$regexp})
        {
            $merged->{$option}->{$regexp}=$group;
        }
        elsif ($ignore_duplicates)
        {
            ; # Nothing to do
        }
        elsif ($merged->{$option}->{$regexp} eq $group)
        {
            verbose("duplicate regular expression '$regexp': '$merged->{$option}->{$regexp}' and '$group'\n");
        }
        else
        {
            verbose("different groups found for regular expression '$regexp': '$merged->{$option}->{$regexp}' and '$group'\n");
        }
    }
}

sub merge_regexp_list($$$$)
{
    my ($merged, $option, $src, $ignore_duplicates)=@_;

    foreach my $item (@$src)
    {
        # Copy $item to avoid the in-place modification of $src
        my $regexp=$item;
        my $group=($regexp =~ s/\s+->\s+(.*)$// ? $1 : $regexp);
        $regexp =~ s/\((?!\?)/(?:/g;
        next if ($regexp eq "");
        if (!exists $merged->{$option}->{$regexp})
        {
            $merged->{$option}->{$regexp}=$group;
        }
        elsif ($ignore_duplicates)
        {
            ; # Nothing to do
        }
        elsif ($merged->{$option}->{$regexp} eq $group)
        {
            verbose("duplicate regular expression '$regexp': '$merged->{$option}->{$regexp}' and '$group'\n");
        }
        else
        {
            verbose("different groups found for regular expression '$regexp': '$merged->{$option}->{$regexp}' and '$group'\n");
        }
    }
}

sub merge_option_set($$;$)
{
    my ($merged, $opt_set, $ignore_duplicates)=@_;
    verbose("merging '$opt_set->{_filename}'\n");

    foreach my $option (keys %{$opt_set})
    {
        if (!ref $opt_set->{$option})
        {
            if (!exists $merged->{$option})
            {
                $merged->{$option}=$opt_set->{$option};
            }
            elsif ($option !~ /^(?:_|rc$|builtin$)/)
            {
                verbose("found duplicate '$option' option in '$opt_set->{_filename}'\n");
            }
        }
        elsif ($option =~ /^(?:bad-word|bad-word_re|bad-expression|bad-expression_re|bad-case|bad-case_re)$/)
        {
            merge_regexp_hash($merged, "_$option", $opt_set->{$option}, $ignore_duplicates);
        }
        elsif ($option =~ /^(?:ignore|include|exclude)$/)
        {
            merge_regexp_list($merged, "_$option", $opt_set->{$option}, $ignore_duplicates);
        }
    }
}

sub get_current_options($$)
{
    my ($allsets, $dir)=@_;
    my $previous_options=$allsets->{merged_stack}->[-1];

    my $new=$previous_options;
    if ($allsets->{cmdline}->{rc})
    {
        if (read_rc_files($allsets, $dir))
        {
            # We found some new files so we have to update the current set
            # of options
            $new=undef;
        }
    }
    if (!$new)
    {
        $new={};
        # Merge all the option sets into one
        merge_option_set($new, $allsets->{cmdline});
        $new->{rcdepth}=(defined $allsets->{rcstack} ? @{$allsets->{rcstack}} : 0);
        if ($allsets->{cmdline}->{rc} and defined $allsets->{rcstack})
        {
            my $i=$new->{rcdepth};
            while ($i > 0)
            {
                $i--;
                merge_option_set($new, $allsets->{rcstack}->[$i]);
                debug("new_exclude=[",join(" | ",keys %{$new->{_exclude}}), "]\n");
                last if (!$new->{rc});
            }
        }
        if ($new->{lintian})
        {
            merge_option_set($new, $allsets->{"lintian-word"}, 1);
            merge_option_set($new, $allsets->{"lintian-case"}, 1);
            merge_option_set($new, $allsets->{"lintian-expr"}, 1);
        }
        if ($new->{codespell})
        {
            merge_option_set($new, $allsets->{codespell}, 1);
        }
        if ($new->{wikipedia})
        {
            merge_option_set($new, $allsets->{wikipedia}, 1);
        }
        if ($new->{builtin})
        {
            merge_option_set($new, $allsets->{builtin}, 1);
        }
        if ($new->{all})
        {
            delete $new->{_include};
        }
        else
        {
            $new->{_include_re}=list_to_regexp($new->{_include});
        }
        $new->{_exclude_re}=list_to_regexp($new->{_exclude});
        $new->{_ignore_re}=list_to_regexp($new->{_ignore});
        my $rebuild_scanner=!defined $previous_options;
        if (!$rebuild_scanner)
        {
          rebuild:
            for (my $i=$previous_options->{rcdepth}; $i < $new->{rcdepth}; $i++)
            {
                my $rc=$allsets->{rcstack}->[$i];
                foreach my $option (@build_scanner_options)
                {
                    if (exists $rc->{$option})
                    {
                        $rebuild_scanner=1;
                        last rebuild;
                    }
                }
            }
        }
        if ($rebuild_scanner)
        {
            build_scanner($allsets, $new);
        }
        else
        {
            # None of the settings that could impact the scanner have changed
            copy_scanner($previous_options, $new);
        }
    }
    push @{$allsets->{merged_stack}}, $new;
    $allsets->{current}=$new;
    return $new;
}

sub pop_current_options($)
{
    my ($allsets)=@_;

    pop @{$allsets->{merged_stack}};
    $allsets->{current}=$allsets->{merged_stack}->[-1];
    if ($allsets->{rcstack})
    {
        my $rcdepth=$allsets->{current} ? $allsets->{current}->{rcdepth} : 0;
        splice @{$allsets->{rcstack}}, $rcdepth;
    }
}


#####
#
# Read the bad words
#
#####

sub split_spec_line($)
{
    my ($spec)=@_;
    return ($1, $2) if ($spec =~ /^(.*)\s*-(?:>|&gt;)\s*(.*)$/);
    return ($spec);
}

sub list_to_regexp($)
{
    my ($list)=@_;
    return undef if (!defined $list or !%$list);
    return "(?:" . join("|", keys %$list) . ")";
}

sub quote_string($)
{
    my ($str)=@_;
    $str =~ s!\\!\\\\!g;
    $str =~ s!([\"\$\@\%])!\\$1!g;
    return "\"$str\"";
}

sub scan_file($$$)
{
    my ($allsets, $current, $filename)=@_;

    my $fh=FileHandle->new("$allsets->{rootdir}/$filename");
    if (!$fh)
    {
        err("unable to open '$filename' for reading: $!\n");
        return 0;
    }
    verbose("scanning '$filename'\n");
    $current->{scanner}($fh, $filename);
    close($fh);
}

sub scan_directory($$);
sub scan_directory($$)
{
    my ($allsets, $dir)=@_;
    verbose("Entering the ", ($dir ? "'$dir'" : "root"), " directory\n");

    my $current=get_current_options($allsets, "$allsets->{rootdir}/$dir");
    debug("current options=[",join(" ", keys %$current),"]\n");
    my $include_re=$current->{_include_re};
    my $exclude_re=$current->{_exclude_re};
    debug("exclude_re=[$exclude_re]\n");

    my @subdirs;
    local *DIR;
    if (!opendir DIR, "$allsets->{rootdir}/$dir")
    {
        err("unable to open the '$allsets->{rootdir}/$dir' directory\n");
        pop_current_options($allsets);
        debug("Exiting the ", ($dir ? "'$dir'" : "root"), " directory\n");
        return;
    }
    foreach my $dentry (readdir(DIR))
    {
        next if ($dentry eq "." or $dentry eq "..");
        $dentry="$dir$dentry";
        my $fullpath="$allsets->{rootdir}/$dentry";
        if (-d $fullpath)
        {
            if (-l $fullpath)
            {
                debug("$dentry/: skipping directory symbolic link\n");
                next;
            }
            $fullpath.="/";
            if ($exclude_re and $fullpath =~ /$exclude_re/)
            {
                verbose("$dentry/: skipping blacklisted directory\n");
                next;
            }
            push @subdirs, $dentry;
            next;
        }
        if (defined $include_re and $fullpath !~ /$include_re/)
        {
            verbose("$dentry: not in whitelist, skipped\n");
            next;
        }
        if ($exclude_re and $fullpath =~ /$exclude_re/)
        {
            verbose("$dentry: skipping blacklisted file\n");
            next;
        }
        scan_file($allsets, $current, $dentry);
    }
    closedir(DIR);

    foreach my $subdir (@subdirs)
    {
        scan_directory($allsets, "$subdir/");
    }
    pop_current_options($allsets);
    debug("Exiting the ", ($dir ? "'$dir'" : "root"), " directory\n");
}

sub print_errors($)
{
    my ($allsets)=@_;
    foreach my $group (sort keys %{$allsets->{errors}})
    {
        print "\n$group:\n";
        print @{$allsets->{errors}->{$group}};
    }
}


#####
#
# Main
#
#####

my ($opt_help);
my $global_options={"debug"   => \$debug,
                    "verbose" => \$verbose,
                    "help"    => \$opt_help
                   };
my $allsets={ rootdir => cwd() };
$allsets->{cmdline}=get_options_set(undef, undef, "cmdline", $global_options);
if (!defined $allsets->{cmdline})
{
    err("try running $name0 --help\n");
    exit 2;
}
$verbose=1 if ($debug);
if ($opt_help)
{
    print "Usage: $name0 [--bad-word WORD] [--bad-expression EXPR] [--bad-case CASE]\n";
    print "             [--ignore IGNORE] [--extra] [--filenames-only|--by-error]\n";
    print "             [--lintian] [--get-codespell] [--codespell] [--get-wikipedia]\n";
    print "             [--wikipedia] [--include SCAN] [--exclude SKIP] [--all]\n";
    print "             [--no-builtin] [--no-rc] [--no-cvsignore] [--no-gitignore]\n";
    print "             [--debug] [--verbose] [--help]\n";

    print "\n";
    print "Scans files for common misspellings and case errors.\n";

    print "\n";
    print "Options:\n";
    print "  --bad-word WORD   A pattern identifying a common typo. This pattern is\n";
    print "                      applied in a case-insensitive way, and can only match\n";
    print "                      full words. It is specified in the following format:\n";
    print "                        PATTERN -> CORRECT\n";
    print "                      Where PATTERN is a Perl regular expression, And CORRECT\n";
    print "                      is the correct spelling of that word\n";
    print "  --bad-expression EXPR A pattern identifying a common typo. This pattern is\n";
    print "                        applied in a case-insensitive way but can span two or\n";
    print "                        more words. It is specified in the same format as the\n";
    print "                        --bad-word argument\n";
    print "  --bad-case CASE   A pattern identifying a common case typo. This pattern is\n";
    print "                        applied in a case-sensitive way, and can only match\n";
    print "                      full words. It is specified in the same format as the\n";
    print "                        --bad-word argument\n";
    print "  --ignore IGNORE   A pattern identifying typos to ignore. This is used to\n";
    print "                      ignore intentional misspellings, or to avoid false\n";
    print "                      positives. It is specified in the following format:\n";
    print "                        PATTERN\n";
    print "                      Where PATTERN is a Perl regular expression\n";
    print "  --extra           If set, then $name0 will consider 'FirstSecond' and\n";
    print "                      'first_second' to be made of two separate words that can\n";
    print "                      be matched by the --bad-word and --bad-case patterns\n";
    print "  --filenames-only  Specifies that only the filename and the line of the first\n";
    print "                      error should be reported\n";
    print "  --by-error        By default errors are reported in the order in which they\n";
    print "                      are found in the files. If this option is specified, all\n";
    print "                      errors of a given type are reported together after all\n";
    print "                      files have been scanned\n";
    print "  --lintian         Use Lintian's list of common misspellings\n";
    print "  --get-codespell   Updates the \$HOME/.$name0.codespell common misspellings\n";
    print "                      list\n";
    print "  --codespell       Use codespell's list of common misspellings\n";
    print "  --get-wikipedia   Updates the \$HOME/.$name0.wikipedia common misspellings\n";
    print "                      list\n";
    print "  --wikipedia       Use Wikipedia's list of common misspellings\n";
    print "  --all             Scan all files not matched by an exclude file pattern\n";
    print "                      By default, only files matching an include file pattern\n";
    print "                      and not matching an exclude file pattern are scanned\n";
    print "  --include SCAN    A Perl regular expression identifying files to scan\n";
    print "  --exclude SKIP    A Perl regular expression identifying files not to scan,\n";
    print "                      typically because they are binary or duplicate files\n";
    print "  --no-builtin      Don't use the builtin list of typos and files scanning options\n";
    print "  --no-rc           Ignore the .typosrc configuration files\n";
    print "  --no-cvsignore    By default $name0 does not scan the files mentionned in the\n";
    print "                      CVS .cvsignore files\n";
    print "  --no-gitignore    By default $name0 does not scan the files mentionned in\n";
    print "                      Git's .gitignore files\n";
    print "  --debug           Prints debug traces\n";
    print "  --verbose         Be more verbose\n";
    print "  --help            Prints this usage message\n";

    print "\n";
    print "File patterns:\n";
    print "  Patterns starting with '^./' identify files relative to the corresponding\n";
    print "  .typosrc directory, or to the current directory for command line options.\n";
    print "   All other file patterns are matched against the file's full path name.\n";
    exit 0;
}

if ($allsets->{cmdline}->{rc})
{
    my $path=cwd();
    my @stack;
    while (1)
    {
        $path=dirname($path);
        last if (!-o $path or $path eq "/");
        unshift @stack, basename($path);
    }
    foreach my $dir (@stack)
    {
        $path="$path/$dir";
        read_rc_files($allsets, $path);
    }
}

if ($allsets->{cmdline}->{lintian})
{
    my $basedir="/usr/share/lintian/vendors/debian/ftp-master-auto-reject/data/spelling";
    $basedir="/usr/share/lintian/data/spelling" if (!-d $basedir);
    my $filename="$basedir/corrections";
    my ($argv, $lines)=lintian2argv($filename, "bad-word");
    $allsets->{"lintian-word"}=get_options_set($argv, $lines, $filename);

    $filename="$basedir/corrections-case";
    ($argv, $lines)=lintian2argv($filename, "bad-case");
    $allsets->{"lintian-case"}=get_options_set($argv, $lines, $filename);

    $filename="$basedir/corrections-multiword";
    ($argv, $lines)=lintian2argv($filename, "bad-expression");
    $allsets->{"lintian-expr"}=get_options_set($argv, $lines, $filename);
}

if ($allsets->{cmdline}->{"get-codespell"})
{
    my $filename="$ENV{HOME}/.$name0.codespell";
    my $cmd="wget --output-document='$filename.tmp' --quiet 'https://raw.githubusercontent.com/lucasdemarchi/codespell/master/data/dictionary.txt'";
    my $rc=system($cmd);
    if ($rc)
    {
        unlink "$filename.tmp";
        err("the codespell download failed (rc=$rc): $cmd\n");
        exit 1;
    }
    if (!rename("$filename.tmp", $filename))
    {
        unlink "$filename.tmp";
        err("could not move '$filename.tmp' into place\n");
        exit 1;
    }
}

if ($allsets->{cmdline}->{codespell})
{
    my $filename="$ENV{HOME}/.$name0.codespell";
    my ($argv, $lines)=codespell2argv($filename);
    $allsets->{"codespell"}=get_options_set($argv, $lines, $filename);
}

if ($allsets->{cmdline}->{"get-wikipedia"})
{
    my $filename="$ENV{HOME}/.$name0.wikipedia";
    my $cmd="wget --output-document='$filename.tmp' --quiet 'https://en.wikipedia.org/wiki/Wikipedia:Lists_of_common_misspellings/For_machines'";
    my $rc=system($cmd);
    if ($rc)
    {
        unlink "$filename.tmp";
        err("the wikipedia download failed (rc=$rc): $cmd\n");
        exit 1;
    }
    if (!rename("$filename.tmp", $filename))
    {
        unlink "$filename.tmp";
        err("could not move '$filename.tmp' into place\n");
        exit 1;
    }
}

if ($allsets->{cmdline}->{wikipedia})
{
    my $filename="$ENV{HOME}/.$name0.wikipedia";
    my ($argv, $lines)=wikipedia2argv($filename);
    $allsets->{"wikipedia"}=get_options_set($argv, $lines, $filename);
}

if ($allsets->{cmdline}->{builtin})
{
    # Read builtin files
    my ($argv, $lines)=rchandle2argv(*DATA, "builtin");
    $allsets->{builtin}=get_options_set($argv, $lines, "builtin");
}

scan_directory($allsets, "");
print_errors($allsets);

exit 0;

__DATA__
# From the Top 100 misspelled English words.
# http://www.yourdictionary.com/library/misspelled.html
bad-word=
    ac(c?epti|ept[ai])ble -> acceptable
    ac(c?ident|idental?)ly -> accidentally
    ([iu]n)?ac(c?omo|omm?o)dat(e[ds]?|ing|ingly) -> accommodate
    ([iu]n)?ad?quir(e[ds]?|ing) -> acquire
    ad?quit(ed)? -> acquit
    alot -> a lot
    amat(er|u?re)s? -> amateur
#apparent
    arguement(e[ds]?|ing|s)? -> argument
    at(ei|hie)st -> atheist
    bele?ive -> believe
    bellw(he|ea)ther -> bellwether
    caland[ae]rs?|calenders? -> calendar
    cateogor(y|ies)|catigory -> category
    cemeta?ry|semet[ae]?ry -> cemetery
#   changable -> changeable   Also handled by the '...able' rule
#collectable and collectible are both valid
    col(lumn?|um) -> column
    com(mit|itt?)(al|e[de]|ers?|ing) -> committed
    con(ch?|s|t)ience -> conscience
    con(ch?|s|t)ien(t|sc|ch?)ious(ly)? -> conscientious
    con(sc?|ch?|t)ien(sc|ch?)ious(ly)? -> conscientious
    con(ch?|s|t)ious -> conscious
    concensus -> consensus
#daiquiri
    definit -> definite
    definate?ly|definitly -> definitely
    di[sc]ipline -> discipline
    drunkeness -> drunkenness
    dumb(be|el?)ls? -> dumbbell
    embar(ra|as?)s(ed|ing(ly)?|ments?)? -> embarrass
    equip[et]ments? -> equipment
    exilarat(e[ds]?|ing(ly)?|ion) -> exhilarate
    exced(e[ds]?|ing(ly)?) -> exceed
    existan(ce|t(ial(ism|ists?)?)?) -> existence
    experiance[ds]? -> experience
    firy -> fiery
    foriegn -> foreign
    guage -> gauge
    greatful -> grateful
    g(a|uar)r[ae]nt(ee?d?|ies|y)|guarr?[ae]nted? -> guarantee
    harrass -> harass
    heigh?ths? -> height
#   hierarchy -> see bad-expression
    humorus -> humorous
    ignoren(ce|t(ly)?) -> ignorance
    im(edi|med)ate?(ly)? -> immediate
    indep(enda|and[ea])n(ce|t(e?ly)?) -> independent
    indispensible -> indispensable
    innoculat(e[ds]?|ing|ion) -> inoculate
    intel(ig[ae]|lige?a)n(ce|t(e?ly|sia)?) -> intelligence
#its and it's only differ in their meaning
    jewelery -> jewelry or jewellery
#judgment and judgement are both valid
#kernel
    liesur(e|ly) -> leisure
    lia(s|i?z)ons? -> liaison
    libar(ies|y) -> library
    lisen[cs](e[ds]?|ing) -> license
#lightening and lightning only differ in their meaning
    maintainance -> maintenance
#maneuver
    midieval -> medieval
    momento -> memento
    mil(en?|le)ni(a|um) -> millennium
    min[ai]tures? -> miniature
#minuscule and miniscule are both valid
    mi(chi?evi?|schev|schi?evi)ous -> mischievous
    mispell(e[ds]?|ings?|s)? -> misspell
    n(ei|ie(gh)?)bou?r(hood)?s? -> neighbor
    (un)?noticabl[ey] -> noticeable
    oc(cas|as?)sion(n?ally|s)? -> occasionally
    oc(urr|cur)(e[ds]?|ences?|ing)|occ?urr?ances? -> occurrence
    pas[st]times? -> pastime
    perseveren(ce|t) -> perseverance
    personel -> personnel
    playrights? -> playwright
    pos(e|es|se)s(e[ds]?|ing|ions?) -> possession
    preceed(e[ds]?|ing(ly|s)?|s)? -> precede
#principal and principle only differ in their meaning
    privi?l(a|ed)ge[ds]? -> privilege
    pronounciations? -> pronunciation
    publicall?y -> publicly
    question(aire?|nair)s? -> questionnaire
    rebel(ed|ing) -> rebelled
#   receive -> see bad-expression
    reciepts? -> receipt
    recom(e|m?a)nd(ab(ility|le)|ed|ing|s) -> recommend
    refer(re|a)nc(e[ds]?|ing) -> reference
    refer(ed|ing) -> referred
    relevent|revel[ae]nt -> relevant
#restaurant
    remit(ed|ing) -> remitted
    rythms? -> rhythm
    shedul(e[ds]?|ers?|ing) -> schedule
    sep(era|are)t(e[ds]?|e?ly|ing|ions?|ors?) -> separate
    sargeants?|sergents? -> sergeant
    supercee?d(e[ds]?|ing|s)?|superseed(e[ds]?|ing|s)?|superseds -> supersede
#their, they're and there only differ in their meaning
    threshholds? -> threshold
    twelth -> twelfth
    tiran?n(ts?|y)|tyrany -> tyranny
    untill -> until
    vacc?u(me?|ume) -> vacuum
    wether -> whether or weather
    wierd(er|est|e?ly)? -> weird
bad-expression=
    \bheirar?ch|\bhierach -> hierarchy
    reciev -> receive

# From the Top 101-250 misspelled English words.
# http://www.yourdictionary.com/library/150more.html
bad-word=
    abscen(ces?|t(e?ly|ee(ism)?)?) -> absence
    acc?ellerat(e[ds]?|ing|or) -> accelerate
    acomplish(ed|ing)? -> accomplish
#accordion
    acumulat(e[ds]?|ing|or) -> accumulate
    aquaintance -> acquaintance
    ac(cros?|c?ro)s -> across
    afficionn?ados?|aficionnados? -> aficionado
#anoint
#apology
#a while: 'awhile' is a valid word too
#barbecue
    begining -> beginning
    broc(col|ol?)li -> broccoli
    bu(is[iy]|sy)ness(es|like|(wo)?m[ae]n) -> business
#camouflage
#candidate
#cantaloupe
    carburatt?or -> carburetor or carburettor
#Caribbean
#cartilage
#chauvinism
#chocolaty
#coliseum
#colonel
    comemorate -> commemorate
#congratulations
    cooly -> coolly
    critisiz(e[ds]?|ing) -> criticize
#Dalmatian
    deciev(e[ds]?|ing) -> deceive
    defendents? -> defendant
#defiant
    des(sic?|s?i)ca(nts?|te[sd]?|ting|tion) -> desiccate
#desperate
    deterrance -> deterrence
    developpe(d|ing|rs?) -> developer
    developements? -> development
    differances? -> difference
#diorama
    dis(sap?|s?a)pear(ances?|e[ds]?|ing|s)? -> disappear
    dis(sap?|s?a)point(e[ds]?|ing|ments?|s) -> disappoint
    dis(ip?|s?ip)pat(e[ds]?|ion) -> dissipate
    e(cs|x)tacy|exta[cs]y -> ecstasy
    e?specialy -> especially
    excel(e|l?a)n(ce|t(ly)?) -> excellent
#exercise
    explaination -> explanation
#Fahrenheit
#flabbergast
    flottation -> flotation
# fulfill is the US spelling of fulfil
#genius
    governement(al) -> government
    grammer -> grammar
#gross
    gut(tur|ur?)ral -> guttural
#handkerchief
    horific -> horrific
    hypocr(a[cs]|ic)y -> hypocrisy
    immitat(e[ds]?|ing|ion) -> imitate
    inadvertant -> inadvertent
    incredabl[ey] -> incredible
#ingenious
#irascible
    irresistable -> irresistible
    knowlege|kowled?ge -> knowledge
#lieutenant
#liquefy
#marshmallow
#mischief
#misogyny
#missile
#nauseous
    noone -> no one
#octopus
    (un)?offical(ly|s)? -> official
#onomatopoeia
    par(r?a|ral?)lel(epiped|ism|ogram)? -> parallel
#parliament
#particular
#peninsula
#pharaoh
#physical
#pigeon
#pistachio
#pleasant
#plenitude
    preferible -> preferable
    presomptuous -> presumptuous
    proced(e?s|ing)? -> proceed
    propogat(e[ds]?|ing|ion) -> propagate
#puerile
#pursue
#putrefy
#raspberry
#refrigerator
#religious
    remembrence -> remembrance
#renowned
#ridiculous
#sacrilegious
#salary
#sandal
    sandw(hit?|it)ch -> sandwich
#savvy
#scissors
    siezed? -> seize
    sensabl[ey] -> sensible
#septuagenarian
    sherifs? -> sheriff
#shish kebab
    seige -> siege
    simmilar(ity|ly)? -> similar
    simmile -> simile
    subpoenna -> subpoena
    suc(ce|es?)s(ful(l|ly|y)?|ion|ive(ly)?|ors?)? -> success
    succ?ess?fuly -> successfully
#tableau
    tar(r?i|rif?)fs? -> tariff
    tom(mor?|m?o)row -> tomorrow
#tongue
    tradgedy -> tragedy
    truely -> truly
#ukulele
    useage -> usage
#vicious
#village
    with[eo]ld -> withhold
bad-expression=
    necces|necesar|\b(un)?nesses|nessary\b -> necessary

# Other common errors
bad-word=
    ([iu]n)?ac(c?e|es?)s(es|[ai]b(le|ility)|ing|ors?) -> accessibility
    ([iu]n)?acc?ess?ab(le|ility) -> accessibility
    ([iu]n)?ache?iv(able|e[ds]?|ers?|ing) -> achieve
    ac(c?o|om?)modat(es?|ing|ions?) -> accommodate
    acknowlege?ment -> acknowledge?ment
    addres(ed|es|ing)?|adress?(ed|es|ing)? -> address
    allowes -> allows
    allready -> already
    allways -> always
    all?way -> always
    altrought? -> although
    amout(ed|ing|s)? -> amount
    anali[sz]e[sd]? -> analyzed
    appartments? -> apartment
    arithmatic -> arithmetic
    argueme?nt(ed|ing|s)? -> argument
    (un)?asign(e[ds]|ing|e?ments?|s)? -> assign
    (un)?asum(e[ds]|ing|s)? -> assume
    aswell -> as well
    att?achements? -> attachment
    atleast -> at least
    automaticly -> automatically
    awfull -> awful
    bec(a|uau?)se -> because
    beeing? -> being
    boundr(y|ies) -> boundary
    (re)?caclulat(e[drs]?|ing(ly)?|ors?) -> calculate
    (re)?calcualt(e[drs]?|ing(ly)?|ors?) -> calculate
    cannt -> cannot
    ([iu]n)?capatib(le|iliti?es|ility) -> capable
    careful[ly] -> carefully
    catched -> caught
    childs -> children
    choosen -> chosen
    codeweaver -> CodeWeavers
    comands? -> command
    (be|in|up)?comming -> coming
    compar(as|[ai]si)ons? -> comparison
    ([iu]n)?compatab(le|ility|ilities) -> compatibility
    completly -> completely
    ([iu]n)?consistan(ci?es|cy|t|tly) -> consistency
    (dis)?contigous(ly)?|(dis)?continous(ly)? -> continuously
    contr(y|ies) -> country
    convertions? -> conversion
    (in)?cor(ect?|rec)lt?y -> correct
    corr?espondance -> correspondence
    coudn?t?|couln?t? -> could
    crosover -> CrossOver
    ([iu]n)?debug(able|e[drs]|ing) -> debugging
    (de|in)cres(e[ds]?|ing(ly)?) -> decrease
    defintions? -> definition
    (in)?dep[ea]nd[ea]nd -> dependent
    (in)?dep(enda|and[ea])nc(e|y|ies) -> dependence
    derivat(e[ds]?|ing) -> derive
    (in)?diferen(ces?|cing|t) -> different
    dissabl(e[ds]?|ing) -> disable
    dito -> ditto
    dynamicly -> dynamically
    easly -> easily
    editt(ed|ing|or) -> editing
    effecien(c[ey]|t(e?ly)?) -> efficience
    eigther -> either
    endianess? -> endianness
    enought -> enough
    eventhought? -> even though
    enviro(ne)?ments? -> environment
    erorr?s? -> error
    excecut(able|e[ds]?|ing|ions?) -> execute
    exeed(ed|ing|s)? -> exceed
    ([iu]n?)e(xe|z)p(e|c|ec)t?(ed(ly)?|ing|(at)?ions?|s)? -> expect
    exlud(e[ds]?|ing) -> exclude
    (ex|im)plic(itely|te?ly|t) -> explicitly
    extentions? -> extension
    ([iu]n)?feasab(le|ility) -> feasible
    feild?(ed|ing|s)?|faild -> failed
    (un)?fomat(ed|ing|s)? -> format
    (un)?fortunatly -> fortunately
    (un)?fullfill?(ed|ing|s) -> fulfill
    funtion(ality|ally|e[ds]?|ing|s)? -> functionning
    garantee(d|s)? -> guarantee
    (un)?handel(e[ds]?|s|ing)? -> handle
    happends? -> happens
    (un)?helpfull -> helpful
    hexidecimal -> hexadecimal
    higly -> highly
    homogenous(ly)? -> homogeneous
    imutable -> immutable
    (ex|im)p(licite|icite?) -> implicit
    (un)?imp?l(ema?n|i?men?|eme?na)t(ations?|ed|ers?|ing|s)? -> implement
    (un)?iml(em[ae]?n|i?me?n|eme?na)t(ations?|ed|ers?|ing|s)? -> implement
    incase -> in case
    incure[ds]? -> incur
    identife[drs]? -> identifier
    inorder -> in order
    (dis)?informations -> information
    (un)?in(i?t[ai]|tia?)l(i[sz](ation|ators?|e[ds]?|ers?|ing)|s)? -> initial
    (un)?initiali[sz]aion -> initialization
    (un)?instal(able|ation|ed|ers?|ing|e?s)? -> installable
    instac(e|iat(e[ds]?|ing|ion)) -> instance
    (un)?intergrat(e[ds]?|ing|ion|or) -> integrated
    inte(f|r?fer)ac(e[ds]?|ing) -> interface
    interfers -> interferes
    (un?)interprett(ed|ers?|ing|ations?) -> interpreted
    (un)?int(er|re)st(e[ds]?|ing|s)? -> interest
    [iu]nvald -> invalid
    invokat(e[ds]?|ing|ion) -> invocation
    (ir)?revelant -> relevant
    (i?un)?kown -> known
    lenght(en|s)? -> length
    langages? -> language
    longuest -> longest
    mes(a|s?e)g(e[ds]?|ing) -> message
    minum(a|al(s|l?y)?|um) -> minimum
    ommit(e[ds]?|ing|ted|s)? -> omit
    oportunit(y|ies) -> opportunity
    opperation(al|s)? -> operation
    optionnal(ly)? -> optional
    or(gi?n|ign?i)(al|ally|at(e[ds]?|ing)|s)? -> origin
    overid(e[ns]?|ing) -> override
    overlap(e[ds]?|ing) -> overlapped
    paintshop -> Paint Shop
    paramaters? -> parameter
    (file)?pathes -> paths
    persistan(ce|t(e?ly)?) -> persistence
    prefer(re|a)nces? -> preference
    prefer(e[ds]?|ing) -> preferring
    presense -> presence
    ([iu][mn])?pro(bi|pa)b(l[ye]|ilit(y|ies)) -> probable
    ([iu][mn])?pro(ba|bi|pa)by -> probable
    programatic(ally)? -> programmatic
    (un)?resonn?abl[ey] -> reasonable
    reg(istr|este?r)(ed?|ing) -> registering
    regestr(ars?|ies|y) -> registry
    relativ -> relative
    reles(e[ds]?|ing) -> release
    remeber(ed|ing|s)? -> remember
    reserverd -> reserved
    res(sour?|s?ou)ces? -> resource
    responces? -> response
    (ir)?responsab(ilit(y|ies)|l[ey]) -> responsibility
    resut(ed|ing|s)? -> result
    retre?iv(als?|e[ds]?|ers?|ing) -> retrieve
    retur(e[ds]?|ing) -> returning
    returnes -> returns
    routinues? -> routine
    secound(ly)? -> second
    seemless -> seamless
    segements? -> segment
    sences? -> sense
    seqenc(e[drs]?|ing)? -> sequence
    (off|re|un)?set(tign|ing)s? -> setting
    ship(ed|ing) -> shipping
    soul?dn?t?|shoudn?t? -> should
    splitted -> split
    (infra)?sturct(ure[ds]?)? -> structure
    subscribtions? -> subscription
    substract(e[ds]|ing|ions?|s)? -> subtract
    (un)?successfull -> successful
    succ?e?d(ed|s)? -> succeed
    (un)?suport(able|e[ds]?|ers?|ing(ly)?|ive|ively|s)? -> support
    supress(e[ds]?|ing|ion)? -> suppress
    (un)?supris(e[ds]?|ing|ingly)? -> surprise
    (a|de|un)?syncron(i[sz]e[drs]?|i[sz]ing|ous(ly)?) -> synchronise
    (sub)?sytems? -> system
    tempor(il)?y -> temporarily
    thats -> that's
    thease -> these
    thier -> their
    throught(out)? -> through
    trafics? -> traffic
    transfer(ed|ing) -> transferred
    transferes -> transfers
    uneeded -> unneeded
    unitiali[sz](ation|e[ds]?|ers?|ing) -> uninitialize
    (un)?useab(ility|le) -> usable
    usefull -> useful
    varios -> various
    unknow -> unknown
    ([iu]n)?visab(le|ility) -> visibility
    volenteers? -> volunteer
    whats -> what's
    whereever -> wherever
    wich -> which
    wieght(ed|ing|s)? -> weight
    qith(out)? -> with
    (over|re|under)?writen -> written
    (over|re|under)writt(ers?|ing) -> writing

bad-expression=
#    "([^"]|\\")*\s\\n([^"]|\\")*" -> no space before '\n'
    (?i)\ba\s+a\b -> 'a' duplicate
    (?i)\bai'?nt\b -> ain't
    (?i)\ban\s+an\b -> 'an' duplicate
    (?i)\babout\s+about\b -> 'about' duplicate
    (?i)\bapplicai -> application
    (?i)\b(are|is|was|were)\s+(are|is|was|were)\b -> 'is' duplicate
    (?i)\b(are|is|'s|was|way|were)\s+to\s+(bad|big|early|great|high|large|late|little|low|new|recent|small|tall)\b -> too
    (?i)\bare'?nt\b -> aren't
    (?i)arilly\b -> '...arily' ending
#    (?i)atinos?\b -> '...ation' ending
    (?i)t(aion|ino)s?\b -> '...tion' ending
    (?i)\bbe\s+be\b -> 'be' duplicate
    (?i)\b(better|bigger|earlier|greater|higher|larger|later|less(\s+recent)?|lower|more(\s+recent)?|newer|rather|smaller|taller|worse)\s+then\b -> than
    (?i)\bby\s+by\b -> 'by' duplicate
    (?i)\bcan\s+not\b -> cannot
    (?i)\scant\s -> can't
    (?i)\bcoud('?nt|n't)?\b -> could
    (?i)\bcould'?nt\b -> couldn't
    (?i)\bdid'?nt\b -> didn't
    (?i)\sdidnt\s -> didn't
    (?i)\bdifferent\s*to\b -> different from
    (?i)\bdo(es|se)?['n ]t\b -> doesn't
    (?i)\sdont\s -> don't
    (?i)[cei]aly\b -> '...ally' ending
    (?i)erd\b -> '...ered' ending
    (?i)\bfor\s+for\b -> 'for' duplicate
    (?i)\bhas'?nt\b -> hasn't
    (?i)\bhave'?nt\b -> haven't
    (?i)\bhavn't\b -> haven't
    (?i)\b(s?he)\s+(s?he|it)\b -> 'he' duplicate
    (?i)[^l]icly\b|icaly\b -> '...ically' ending
    (?i)\bif\s+if\b -> 'if' duplicate
    (?i)ifing\b -> '...ifing' ending
    (?i)\bin\s+in\b -> 'in' duplicate
    (?i)\bisnt\b -> isn't
    (?i)\bit\s+it\b -> 'it' duplicate
    (?i)\bmean\s+time\b -> meantime
    (?i)naly\b -> '...nally' ending
    (?i)non\s+exist(ent|ing) -> nonexistent
    (?i)nonexistant -> nonexistent
    (?i)\bof\s+of\b -> 'of' duplicate
    (?i)onnally\b -> '...onaly' ending
    (?i)procces -> process
    (?i)\bshoud('?nt|n't)?\b -> should
    (?i)\bshould'?nt\b -> shouldn't
    (?i)\bsome\s+how\b -> somehow
    (?i)\bsome\s+what\b -> somewhat
    (?i)\bsome\s+where\b -> somewhere
    (?i)[^begiouy]eing\b -> '...ing' ending
    (?i)[^ecgklmprsvz]eable\b -> '...able' ending
    (?i)\steh\s -> the
    (?i)\bthe\s+the\b -> 'the' duplicate
    (?i)\sths\s -> this
    (?i)\stje\s -> the
    (?i)then\s+expected -> than
    (?i)\btheir\s+(are|is|was|were)\b -> there is
    (?i)trys\b -> tries
    (?i)ualy\b -> '...ually' ending
    (?i)\bunece -> unnecessary
    (?i)\bupto\b -> up to
    (?i)\bwa(n'|s'?n)t\b -> wasn't
    (?i)\swih\s -> with
    (?i)\bwith\s+with\b -> 'with' duplicate
    (?i)\bwould'?nt\b -> wouldn't
bad-case=
    [aA]nd\s+and -> 'and' duplicate
    [Aa]uthorWare -> Authorware
    Autocad|[Aa]uto(Cad|cAd|caD|CAd|CaD|cAD) -> AutoCAD
    Black?Box|black?Box -> Blackbox
    BlockBuster|blockBuster -> Blockbuster
    Boot(\s*c|C)amp -> Boot Camp
    Codeweavers|codeWeavers -> CodeWeavers
    Crossover|crossOver -> CrossOver
    [Dd]reamWeaver -> Dreamweaver
    directDraw|Directdraw -> DirectDraw
    directInput|Directinput -> DirectInput
    directMusic|Directmusic -> DirectMusic
    directPlay|Directplay -> DirectPlay
    directSound|Directsound -> DirectSound
    directX|Directx -> DirectX
    [Ee]xec[Ss]hield -> Exec Shield
    Exec\s+shield -> Exec Shield
    [Ff]ireWorks -> Fireworks
    Fontforge|fontForge -> FontForge
    Framemaker|frameMaker -> FrameMaker
    Freebsd|[Ff]ree(Bsd|bSd|bsD|BSd|BsD|bSD) -> FreeBSD
    [Ff]reeHand -> FreeHand
    Freetype|freeType -> FreeType
    Frontpage|frontPage -> FrontPage
    Geforce|geForce -> GeForce
    GMail -> Gmail
    Half(L|-?l)ife -> Half-Life or Half life
    [Hh]omeSite -> Homesite
    Installshield|installShield -> InstallShield
    Left4[Dd]ead -> Left 4 Dead
    Linux\s*world -> LinuxWorld
    M(?i:acOSX) -> Mac OS X
    M(?i:acOS |ac OS)[xX] -> Mac OS X
#   Count on the ignore directive to not complain on the correct spelling
    (?i:Mac OS X) -> Mac OS X
    [Mm]acroMedia -> Macromedia
    [Mm]ac\s*World -> Macworld
    [M]aster[ -]?card|master[ -]?Card -> MasterCard
    [Mm]icroSoft -> Microsoft
    Netmeeting -> NetMeeting
    News?forge -> NewsForge
    Onenote|oneNote -> OneNote
    Pagemaker|pageMaker -> PageMaker
    Paypal|payPal -> PayPal
    [Pp]hotoShop -> Photoshop
    Powerpoint|powerPoint -> PowerPoint
    Pulseaudio|pulseAudio -> PulseAudio
    Quickbooks?|quickBooks? -> QuickBooks
    Quicktime|quickTime -> QuickTime
    Red[Hh]at -> Red Hat
    [Ss]hockWave -> Shockwave
    (Sel|SEl|SeL|seL|sEL|sEl)inux -> SELinux
    Starcraft -> StarCraft
    Su(se|Se|sE) -> SUSE
    Tarent(ell?a|all?a)|Tarant(ela|all?a) -> Tarantella
    Transgaming|transGaming -> TransGaming
    Turbotax|turboTax -> TurboTax
    Virtualbox|virtualBox -> VirtualBox
    [Vv][Mm]Ware -> VMware
    Winehq|[Ww]ine(Hq|hQ) -> WineHQ
    Winetools|wineTools -> WineTools
    Wordperfect|wordPerfect -> WordPerfect
    Xrender -> XRender
ignore=
    \bAFAIR\b
    (?i:anteing)
    BE\s+BE
    \bMACOSX\b
    \bMac\s+OS\s+X\b

include=
    \.(?i:c|cpp|cxx|h|idl|m)$
    \.(l|y)$
    \.(?i:nib|plist|strings)$
    \.(?i:s?html?)$
    \.in$
    \.(?i:pas)$
    \.pm$
    \.php$
    \.py$
    \.(?i:sgml|xml)$
    \.(itcl|itk|tcl)$
    \.(?i:rc)$
    \.spec$
exclude=
    \.(a|o|la|ko|so(\.[0-9]+)*)$
    \.(?i:dll|exe|obj|res|tlb)$
    \.(?i:ncb|opt)$
    \.mo$
    \.(?i:mp3|ogg|wma)$
    \.(?i:avi|mpeg|mpg|mp4|ogv|swf|wmv)$
    \.(?i:cur|bmp|eps|gif|icns|ico|jpe?g|pdf|png|ps|tiff|xcf|xpm)$
    \.(?i:fon|fnt|ttf)$
    \.(?i:docx|od[bcfgimst]|ppt|pptx|xls|xlsx)$
    \.(bz2|deb|gz|rpm|tar|tgz|xz)$
    \.(?i:zip)$
    /autom4te\.cache/
    /CVS/
    /\.cvsignore$
    /\.defs/
    /\.git/
    /\.gitignore$
    /\.libs/
    /\.typosrc$
    ~$
    /\.#[^/]*$
    /#[^/]*#$
